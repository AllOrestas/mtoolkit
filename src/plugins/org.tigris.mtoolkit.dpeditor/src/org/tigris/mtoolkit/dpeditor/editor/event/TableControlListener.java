/*******************************************************************************
 * Copyright (c) 2005, 2009 ProSyst Software GmbH and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     ProSyst Software GmbH - initial API and implementation
 *******************************************************************************/
package org.tigris.mtoolkit.dpeditor.editor.event;

import org.eclipse.swt.SWT;
import org.eclipse.swt.events.ControlAdapter;
import org.eclipse.swt.events.ControlEvent;
import org.eclipse.swt.graphics.Point;
import org.eclipse.swt.graphics.Rectangle;
import org.eclipse.swt.widgets.Composite;
import org.eclipse.swt.widgets.Table;
import org.eclipse.swt.widgets.TableColumn;

/**
 * Provide methods that deal with the events that are generated by moving and
 * resizing controls.
 * 
 * After creating a class it can be added to a control using the
 * <code>addControlListener</code> method and removed using the
 * <code>removeControlListener</code> method. When a control is moved or
 * resized, the appropriate method will be invoked.
 * 
 * @see ControlAdapter
 * @see ControlEvent
 */
public class TableControlListener extends ControlAdapter {

	/** The moving and resizing control */
	private Table table;
	/** The mode describing the control's behavior */
	private int resizeMode = EventConstants.DEFAULT_RESIZE_MODE;

	/**
	 * Creates the new TableControlListener and sets the control which moving
	 * and resizing will be watched by this listener.
	 * 
	 * @param table
	 *            the control which will be watched
	 */
	public TableControlListener(Table table) {
		this.table = table;
	}

	/**
	 * Sets the mode which describing the control's behavior.
	 * 
	 * @param mode
	 *            the new mode of control's behavior. The mode must be one of
	 *            the <code>EventConstants</code> value
	 */
	public void setResizeMode(int mode) {
		this.resizeMode = mode;
	}

	/**
	 * Sent when the size (width, height) of a control changes. Calls resize
	 * column method.
	 * 
	 * @param e
	 *            an event containing information about the resize
	 * @see org.eclipse.swt.events.ControlAdapter#controlResized(org.eclipse.swt.events.ControlEvent)
	 */
	public void controlResized(ControlEvent e) {
		Composite parent = table.getParent();
		Rectangle area = parent.getClientArea();
		Point preferredSize = table.computeSize(SWT.DEFAULT, SWT.DEFAULT);
		int width = area.width - 1;
		Rectangle oldSize = table.getClientArea();
		if (preferredSize.y > area.height + table.getHeaderHeight() - parent.getBounds().y * 3 + 2) {
			// Subtract the scrollbar width from the total column width
			// if a vertical scrollbar will be required
			Point vBarSize = table.getVerticalBar().getSize();
			width -= vBarSize.x;
		}

		if (oldSize.width > area.width) {
			// table is getting smaller so make the columns
			// smaller first and then resize the table to
			// match the client area width
			resizeColumns(width);
			table.setSize(area.width, area.height - 2);
		} else {
			// table is getting bigger so make the table
			// bigger first and then make the columns wider
			// to match the client area width
			table.setSize(area.width, area.height - 2);
			resizeColumns(width);
		}
	}

	/**
	 * Resizes columns of the given table, depending of the given absolute
	 * table's width and of the mode, which is describing the behavior of the
	 * table.
	 * 
	 * @param absoluteTableWidth
	 *            the absolute width of the table
	 */
	private void resizeColumns(int absoluteTableWidth) {
		if ((resizeMode == EventConstants.DEFAULT_RESIZE_MODE)) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1 + table.getBorderWidth();
			table.getColumns()[0].setWidth(absoluteTableWidth);
		} else if (resizeMode == EventConstants.HEADERS_RESIZE_MODE) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1;
			TableColumn[] columns = table.getColumns();
			if (columns.length < 2)
				return;
			columns[0].setWidth(absoluteTableWidth / 3);
			columns[1].setWidth(absoluteTableWidth - columns[0].getWidth());
		} else if (resizeMode == EventConstants.BUNDLES_RESIZE_MODE) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1;
			TableColumn[] columns = table.getColumns();
			columns[0].setWidth(absoluteTableWidth / 4);
			columns[1].setWidth(absoluteTableWidth / 5);
			columns[2].setWidth(absoluteTableWidth / 5);
			columns[3].setWidth(3 * absoluteTableWidth / 40);
			columns[4].setWidth(7 * absoluteTableWidth / 80);
			columns[5].setWidth(3 * absoluteTableWidth / 40);
			columns[6].setWidth(absoluteTableWidth - columns[0].getWidth() * 71 / 20);
		} else if (resizeMode == EventConstants.RESOURCES_RESIZE_MODE) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1;
			TableColumn[] columns = table.getColumns();
			columns[0].setWidth(2 * absoluteTableWidth / 7);
			columns[1].setWidth(2 * absoluteTableWidth / 8);
			columns[2].setWidth(2 * absoluteTableWidth / 8);
			columns[3].setWidth(absoluteTableWidth / 10);
			columns[4].setWidth(absoluteTableWidth - columns[0].getWidth() * 5 / 2);
		} else if (resizeMode == EventConstants.CERTIFICATES_RESIZE_MODE) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1;
			TableColumn[] columns = table.getColumns();
			columns[0].setWidth(absoluteTableWidth / 5);
			columns[1].setWidth(absoluteTableWidth / 5);
			columns[2].setWidth(absoluteTableWidth / 5);
			columns[3].setWidth(absoluteTableWidth / 5);
			columns[4].setWidth(absoluteTableWidth - columns[3].getWidth() * 4);
		} else if (resizeMode == EventConstants.CERTIFICATES_SECOND_RESIZE_MODE) {
			absoluteTableWidth = absoluteTableWidth - (table.getBounds().x * 2) + 1;
			TableColumn[] columns = table.getColumns();
			columns[0].setWidth(absoluteTableWidth / 4);
			columns[1].setWidth(absoluteTableWidth / 4);
			columns[2].setWidth(absoluteTableWidth / 4);
			columns[3].setWidth(absoluteTableWidth - columns[2].getWidth() * 3);
		}
	}
}